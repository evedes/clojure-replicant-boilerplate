shadow$provide.module$node_modules$snabbdom$build$snabbdom_cjs = function(global, require, module, exports) {
  function parentNode(node) {
    if (isDocumentFragment$1(node)) {
      for (; node && isDocumentFragment$1(node);) {
        node = parseFragment(node).parent;
      }
      return null !== node && void 0 !== node ? node : null;
    }
    return node.parentNode;
  }
  function isDocumentFragment$1(node) {
    return 11 === node.nodeType;
  }
  function parseFragment(fragmentNode, parentNode) {
    var _a, _b, _c;
    null !== (_a = fragmentNode.parent) && void 0 !== _a ? _a : fragmentNode.parent = null !== parentNode && void 0 !== parentNode ? parentNode : null;
    null !== (_b = fragmentNode.firstChildNode) && void 0 !== _b ? _b : fragmentNode.firstChildNode = fragmentNode.firstChild;
    null !== (_c = fragmentNode.lastChildNode) && void 0 !== _c ? _c : fragmentNode.lastChildNode = fragmentNode.lastChild;
    return fragmentNode;
  }
  function vnode(sel, data, children, text, elm) {
    return {sel, data, children, text, elm, key:void 0 === data ? void 0 : data.key};
  }
  function primitive(s) {
    return "string" === typeof s || "number" === typeof s || s instanceof String || s instanceof Number;
  }
  function sameVnode(vnode1, vnode2) {
    var _a, _b;
    const isSameKey = vnode1.key === vnode2.key, isSameIs = (null === (_a = vnode1.data) || void 0 === _a ? void 0 : _a.is) === (null === (_b = vnode2.data) || void 0 === _b ? void 0 : _b.is);
    _a = vnode1.sel || vnode1.sel !== vnode2.sel ? !0 : typeof vnode1.text === typeof vnode2.text;
    return vnode1.sel === vnode2.sel && isSameKey && isSameIs && _a;
  }
  function documentFragmentIsNotSupported() {
    throw Error("The document fragment is not supported on this platform.");
  }
  function addNS(data, children, sel) {
    data.ns = "http://www.w3.org/2000/svg";
    if ("foreignObject" !== sel && void 0 !== children) {
      for (data = 0; data < children.length; ++data) {
        sel = children[data];
        if ("string" === typeof sel) {
          continue;
        }
        const childData = sel.data;
        void 0 !== childData && addNS(childData, sel.children, sel.sel);
      }
    }
  }
  function h(sel, b, c) {
    let data = {}, children, text;
    void 0 !== c ? (null !== b && (data = b), array(c) ? children = c : primitive(c) ? text = c.toString() : c && c.sel && (children = [c])) : void 0 !== b && null !== b && (array(b) ? children = b : primitive(b) ? text = b.toString() : b && b.sel ? children = [b] : data = b);
    if (void 0 !== children) {
      for (b = 0; b < children.length; ++b) {
        primitive(children[b]) && (children[b] = vnode(void 0, void 0, void 0, children[b], void 0));
      }
    }
    "s" !== sel[0] || "v" !== sel[1] || "g" !== sel[2] || 3 !== sel.length && "." !== sel[3] && "#" !== sel[3] || addNS(data, children, sel);
    return vnode(sel, data, children, text, void 0);
  }
  function copyToThunk(vnode, thunk) {
    var _a;
    const ns = null === (_a = thunk.data) || void 0 === _a ? void 0 : _a.ns;
    vnode.data.fn = thunk.data.fn;
    vnode.data.args = thunk.data.args;
    thunk.data = vnode.data;
    thunk.children = vnode.children;
    thunk.text = vnode.text;
    thunk.elm = vnode.elm;
    ns && addNS(thunk.data, thunk.children, thunk.sel);
  }
  function init(thunk) {
    var cur = thunk.data;
    cur = cur.fn(...cur.args);
    copyToThunk(cur, thunk);
  }
  function prepatch(oldVnode, thunk) {
    var i = oldVnode.data;
    const cur = thunk.data, oldArgs = i.args, args = cur.args;
    if (i.fn !== cur.fn || oldArgs.length !== args.length) {
      copyToThunk(cur.fn(...args), thunk);
    } else {
      for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
          copyToThunk(cur.fn(...args), thunk);
          return;
        }
      }
      copyToThunk(oldVnode, thunk);
    }
  }
  function pre(vnode, newVnode) {
    const attachData = vnode.data.attachData;
    newVnode.data.attachData.placeholder = attachData.placeholder;
    newVnode.data.attachData.real = attachData.real;
    vnode.elm = vnode.data.attachData.real;
  }
  function post(_, vnode) {
    vnode.elm = vnode.data.attachData.placeholder;
  }
  function destroy(vnode) {
    void 0 !== vnode.elm && vnode.elm.parentNode.removeChild(vnode.elm);
    vnode.elm = vnode.data.attachData.real;
  }
  function create(_, vnode) {
    _ = vnode.elm;
    const attachData = vnode.data.attachData, placeholder = document.createElement("span");
    vnode.elm = placeholder;
    attachData.target.appendChild(_);
    attachData.real = _;
    attachData.placeholder = placeholder;
  }
  function toVNode(node, domApi) {
    var api = void 0 !== domApi ? domApi : htmlDomApi;
    if (api.isElement(node)) {
      var id = node.id ? "#" + node.id : "", cn = node.getAttribute("class");
      cn = cn ? "." + cn.split(" ").join(".") : "";
      api = api.tagName(node).toLowerCase() + id + cn;
      id = {};
      cn = {};
      const data = {}, children = [];
      let name, i, n;
      const elmAttrs = node.attributes, elmChildren = node.childNodes;
      i = 0;
      for (n = elmAttrs.length; i < n; i++) {
        name = elmAttrs[i].nodeName, "d" === name[0] && "a" === name[1] && "t" === name[2] && "a" === name[3] && "-" === name[4] ? cn[name.slice(5)] = elmAttrs[i].nodeValue || "" : "id" !== name && "class" !== name && (id[name] = elmAttrs[i].nodeValue);
      }
      i = 0;
      for (n = elmChildren.length; i < n; i++) {
        children.push(toVNode(elmChildren[i], domApi));
      }
      0 < Object.keys(id).length && (data.attrs = id);
      0 < Object.keys(cn).length && (data.dataset = cn);
      "s" !== api[0] || "v" !== api[1] || "g" !== api[2] || 3 !== api.length && "." !== api[3] && "#" !== api[3] || addNS(data, children, api);
      return vnode(api, data, children, void 0, node);
    }
    return api.isText(node) ? (domApi = api.getTextContent(node), vnode(void 0, void 0, void 0, domApi, node)) : api.isComment(node) ? (domApi = api.getTextContent(node), vnode("!", {}, [], domApi, node)) : vnode("", {}, [], void 0, node);
  }
  function updateAttrs(oldVnode, vnode) {
    let key;
    const elm = vnode.elm;
    oldVnode = oldVnode.data.attrs;
    vnode = vnode.data.attrs;
    if ((oldVnode || vnode) && oldVnode !== vnode) {
      oldVnode = oldVnode || {};
      vnode = vnode || {};
      for (key in vnode) {
        const cur = vnode[key];
        oldVnode[key] !== cur && (!0 === cur ? elm.setAttribute(key, "") : !1 === cur ? elm.removeAttribute(key) : 120 !== key.charCodeAt(0) ? elm.setAttribute(key, cur) : 58 === key.charCodeAt(3) ? elm.setAttributeNS("http://www.w3.org/XML/1998/namespace", key, cur) : 58 === key.charCodeAt(5) ? elm.setAttributeNS("http://www.w3.org/1999/xlink", key, cur) : elm.setAttribute(key, cur));
      }
      for (key in oldVnode) {
        key in vnode || elm.removeAttribute(key);
      }
    }
  }
  function updateClass(oldVnode, vnode) {
    let name;
    const elm = vnode.elm;
    oldVnode = oldVnode.data.class;
    let klass = vnode.data.class;
    if ((oldVnode || klass) && oldVnode !== klass) {
      oldVnode = oldVnode || {};
      klass = klass || {};
      for (name in oldVnode) {
        oldVnode[name] && !Object.prototype.hasOwnProperty.call(klass, name) && elm.classList.remove(name);
      }
      for (name in klass) {
        if (vnode = klass[name], vnode !== oldVnode[name]) {
          elm.classList[vnode ? "add" : "remove"](name);
        }
      }
    }
  }
  function updateDataset(oldVnode, vnode) {
    const elm = vnode.elm;
    oldVnode = oldVnode.data.dataset;
    vnode = vnode.data.dataset;
    let key;
    if ((oldVnode || vnode) && oldVnode !== vnode) {
      oldVnode = oldVnode || {};
      vnode = vnode || {};
      var d = elm.dataset;
      for (key in oldVnode) {
        vnode[key] || (d ? key in d && delete d[key] : elm.removeAttribute("data-" + key.replace(CAPS_REGEX, "-$\x26").toLowerCase()));
      }
      for (key in vnode) {
        oldVnode[key] !== vnode[key] && (d ? d[key] = vnode[key] : elm.setAttribute("data-" + key.replace(CAPS_REGEX, "-$\x26").toLowerCase(), vnode[key]));
      }
    }
  }
  function invokeHandler(handler, vnode, event) {
    if ("function" === typeof handler) {
      handler.call(vnode, event, vnode);
    } else if ("object" === typeof handler) {
      for (let i = 0; i < handler.length; i++) {
        invokeHandler(handler[i], vnode, event);
      }
    }
  }
  function createListener() {
    return function handler(event) {
      var vnode = handler.vnode;
      const name = event.type, on = vnode.data.on;
      on && on[name] && invokeHandler(on[name], vnode, event);
    };
  }
  function updateEventListeners(oldVnode, vnode) {
    const oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = vnode && vnode.elm;
    let name;
    if (oldOn !== on) {
      if (oldOn && oldListener) {
        if (on) {
          for (name in oldOn) {
            on[name] || oldElm.removeEventListener(name, oldListener, !1);
          }
        } else {
          for (name in oldOn) {
            oldElm.removeEventListener(name, oldListener, !1);
          }
        }
      }
      if (on) {
        if (oldVnode = vnode.listener = oldVnode.listener || createListener(), oldVnode.vnode = vnode, oldOn) {
          for (name in on) {
            oldOn[name] || elm.addEventListener(name, oldVnode, !1);
          }
        } else {
          for (name in on) {
            elm.addEventListener(name, oldVnode, !1);
          }
        }
      }
    }
  }
  function updateProps(oldVnode, vnode) {
    let key, old;
    const elm = vnode.elm;
    oldVnode = oldVnode.data.props;
    let props = vnode.data.props;
    if ((oldVnode || props) && oldVnode !== props) {
      for (key in oldVnode = oldVnode || {}, props = props || {}, props) {
        vnode = props[key], old = oldVnode[key], old === vnode || "value" === key && elm[key] === vnode || (elm[key] = vnode);
      }
    }
  }
  function setNextFrame(obj, prop, val) {
    nextFrame(function() {
      obj[prop] = val;
    });
  }
  function updateStyle(oldVnode, vnode) {
    let name;
    const elm = vnode.elm;
    oldVnode = oldVnode.data.style;
    let style = vnode.data.style;
    if ((oldVnode || style) && oldVnode !== style) {
      oldVnode = oldVnode || {};
      style = style || {};
      var oldHasDel = "delayed" in oldVnode;
      for (name in oldVnode) {
        style[name] || ("-" === name[0] && "-" === name[1] ? elm.style.removeProperty(name) : elm.style[name] = "");
      }
      for (name in style) {
        if (vnode = style[name], "delayed" === name && style.delayed) {
          for (const name2 in style.delayed) {
            vnode = style.delayed[name2], oldHasDel && vnode === oldVnode.delayed[name2] || setNextFrame(elm.style, name2, vnode);
          }
        } else {
          "remove" !== name && vnode !== oldVnode[name] && ("-" === name[0] && "-" === name[1] ? elm.style.setProperty(name, vnode) : elm.style[name] = vnode);
        }
      }
    }
  }
  function flattenAndFilter(children, flattened) {
    for (const child of children) {
      void 0 !== child && null !== child && !1 !== child && "" !== child && (Array.isArray(child) ? flattenAndFilter(child, flattened) : "string" === typeof child || "number" === typeof child || "boolean" === typeof child ? flattened.push(vnode(void 0, void 0, void 0, String(child), void 0)) : flattened.push(child));
    }
    return flattened;
  }
  function jsx(tag, data, ...children) {
    children = flattenAndFilter(children, []);
    return "function" === typeof tag ? tag(data, children) : 1 === children.length && !children[0].sel && children[0].text ? h(tag, data, children[0].text) : h(tag, data, children);
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  const htmlDomApi = {createElement:function(tagName, options) {
    return document.createElement(tagName, options);
  }, createElementNS:function(namespaceURI, qualifiedName, options) {
    return document.createElementNS(namespaceURI, qualifiedName, options);
  }, createTextNode:function(text) {
    return document.createTextNode(text);
  }, createDocumentFragment:function() {
    return parseFragment(document.createDocumentFragment());
  }, createComment:function(text) {
    return document.createComment(text);
  }, insertBefore:function(parentNode, newNode, referenceNode) {
    if (isDocumentFragment$1(parentNode)) {
      let node = parentNode;
      for (; node && isDocumentFragment$1(node);) {
        node = parseFragment(node).parent;
      }
      parentNode = null !== node && void 0 !== node ? node : parentNode;
    }
    isDocumentFragment$1(newNode) && (newNode = parseFragment(newNode, parentNode));
    referenceNode && isDocumentFragment$1(referenceNode) && (referenceNode = parseFragment(referenceNode).firstChildNode);
    parentNode.insertBefore(newNode, referenceNode);
  }, removeChild:function(node, child) {
    node.removeChild(child);
  }, appendChild:function(node, child) {
    isDocumentFragment$1(child) && (child = parseFragment(child, node));
    node.appendChild(child);
  }, parentNode, nextSibling:function(node) {
    var _a;
    if (isDocumentFragment$1(node)) {
      node = parseFragment(node);
      var parent = parentNode(node);
      return parent && node.lastChildNode ? (parent = Array.from(parent.childNodes), node = parent.indexOf(node.lastChildNode), null !== (_a = parent[node + 1]) && void 0 !== _a ? _a : null) : null;
    }
    return node.nextSibling;
  }, tagName:function(elm) {
    return elm.tagName;
  }, setTextContent:function(node, text) {
    node.textContent = text;
  }, getTextContent:function(node) {
    return node.textContent;
  }, isElement:function(node) {
    return 1 === node.nodeType;
  }, isText:function(node) {
    return 3 === node.nodeType;
  }, isComment:function(node) {
    return 8 === node.nodeType;
  }, isDocumentFragment:isDocumentFragment$1}, array = Array.isArray, emptyNode = vnode("", {}, [], void 0, void 0), hooks = "create update remove destroy pre post".split(" ");
  global = {create:updateAttrs, update:updateAttrs};
  require = {create:updateClass, update:updateClass};
  const CAPS_REGEX = /[A-Z]/g;
  module = {create:updateDataset, update:updateDataset};
  const eventListenersModule = {create:updateEventListeners, update:updateEventListeners, destroy:updateEventListeners}, propsModule = {create:updateProps, update:updateProps}, raf = "undefined" !== typeof window && window.requestAnimationFrame.bind(window) || setTimeout, nextFrame = function(fn) {
    raf(function() {
      raf(fn);
    });
  };
  let reflowForced = !1;
  const styleModule = {pre:function() {
    reflowForced = !1;
  }, create:updateStyle, update:updateStyle, destroy:function(vnode) {
    let style, name;
    const elm = vnode.elm;
    if ((vnode = vnode.data.style) && (style = vnode.destroy)) {
      for (name in style) {
        elm.style[name] = style[name];
      }
    }
  }, remove:function(vnode, rm) {
    var s = vnode.data.style;
    if (s && s.remove) {
      reflowForced || (vnode.elm.offsetLeft, reflowForced = !0);
      var name, elm = vnode.elm;
      vnode = 0;
      var style = s.remove, amount = 0;
      s = [];
      for (name in style) {
        s.push(name), elm.style[name] = style[name];
      }
      for (name = getComputedStyle(elm)["transition-property"].split(", "); vnode < name.length; ++vnode) {
        -1 !== s.indexOf(name[vnode]) && amount++;
      }
      elm.addEventListener("transitionend", function(ev) {
        ev.target === elm && --amount;
        0 === amount && rm();
      });
    } else {
      rm();
    }
  }};
  (function(jsx) {
  })(jsx || (jsx = {}));
  exports.Fragment = function(data, ...children) {
    children = flattenAndFilter(children, []);
    return 1 === children.length && !children[0].sel && children[0].text ? vnode(void 0, void 0, void 0, children[0].text, void 0) : vnode(void 0, null !== data && void 0 !== data ? data : {}, children, void 0, void 0);
  };
  exports.array = array;
  exports.attachTo = function(target, vnode) {
    void 0 === vnode.data && (vnode.data = {});
    void 0 === vnode.data.hook && (vnode.data.hook = {});
    const hook = vnode.data.hook;
    vnode.data.attachData = {target, placeholder:void 0, real:void 0};
    hook.create = create;
    hook.prepatch = pre;
    hook.postpatch = post;
    hook.destroy = destroy;
    return vnode;
  };
  exports.attributesModule = global;
  exports.classModule = require;
  exports.datasetModule = module;
  exports.eventListenersModule = eventListenersModule;
  exports.fragment = function(children) {
    let c, text;
    array(children) ? c = children : primitive(c) ? text = children : c && c.sel && (c = [children]);
    if (void 0 !== c) {
      for (children = 0; children < c.length; ++children) {
        primitive(c[children]) && (c[children] = vnode(void 0, void 0, void 0, c[children], void 0));
      }
    }
    return vnode(void 0, {}, c, text, void 0);
  };
  exports.h = h;
  exports.htmlDomApi = htmlDomApi;
  exports.init = function(modules, domApi, options) {
    function createRmCb(childElm, listeners) {
      return function() {
        if (0 === --listeners) {
          const parent = api.parentNode(childElm);
          api.removeChild(parent, childElm);
        }
      };
    }
    function createElm(vnode, insertedVnodeQueue) {
      var _a, _b, i, data = vnode.data;
      if (void 0 !== data) {
        var init = null === (_a = data.hook) || void 0 === _a ? void 0 : _a.init;
        void 0 !== init && (init(vnode), data = vnode.data);
      }
      _a = vnode.children;
      init = vnode.sel;
      if ("!" === init) {
        void 0 === vnode.text && (vnode.text = ""), vnode.elm = api.createComment(vnode.text);
      } else if (void 0 !== init) {
        var hashIdx = init.indexOf("#");
        var _c = init.indexOf(".", hashIdx);
        var _d = 0 < hashIdx ? hashIdx : init.length;
        const dot = 0 < _c ? _c : init.length, tag = -1 !== hashIdx || -1 !== _c ? init.slice(0, Math.min(_d, dot)) : init;
        hashIdx = vnode.elm = void 0 !== data && void 0 !== (i = data.ns) ? api.createElementNS(i, tag, data) : api.createElement(tag, data);
        _d < dot && hashIdx.setAttribute("id", init.slice(_d + 1, dot));
        0 < _c && hashIdx.setAttribute("class", init.slice(dot + 1).replace(/\./g, " "));
        for (i = 0; i < cbs.create.length; ++i) {
          cbs.create[i](emptyNode, vnode);
        }
        if (array(_a)) {
          for (i = 0; i < _a.length; ++i) {
            data = _a[i], null != data && api.appendChild(hashIdx, createElm(data, insertedVnodeQueue));
          }
        } else {
          primitive(vnode.text) && api.appendChild(hashIdx, api.createTextNode(vnode.text));
        }
        i = vnode.data.hook;
        void 0 !== i && (null === (_b = i.create) || void 0 === _b || _b.call(i, emptyNode, vnode), i.insert && insertedVnodeQueue.push(vnode));
      } else if ((null === (_c = null === options || void 0 === options ? void 0 : options.experimental) || void 0 === _c ? 0 : _c.fragments) && vnode.children) {
        vnode.elm = (null !== (_d = api.createDocumentFragment) && void 0 !== _d ? _d : documentFragmentIsNotSupported)();
        for (i = 0; i < cbs.create.length; ++i) {
          cbs.create[i](emptyNode, vnode);
        }
        for (i = 0; i < vnode.children.length; ++i) {
          _b = vnode.children[i], null != _b && api.appendChild(vnode.elm, createElm(_b, insertedVnodeQueue));
        }
      } else {
        vnode.elm = api.createTextNode(vnode.text);
      }
      return vnode.elm;
    }
    function invokeDestroyHook(vnode) {
      var _a, _b;
      const data = vnode.data;
      if (void 0 !== data) {
        null === (_b = null === (_a = null === data || void 0 === data ? void 0 : data.hook) || void 0 === _a ? void 0 : _a.destroy) || void 0 === _b || _b.call(_a, vnode);
        for (_a = 0; _a < cbs.destroy.length; ++_a) {
          cbs.destroy[_a](vnode);
        }
        if (void 0 !== vnode.children) {
          for (_a = 0; _a < vnode.children.length; ++_a) {
            _b = vnode.children[_a], null != _b && "string" !== typeof _b && invokeDestroyHook(_b);
          }
        }
      }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
      for (var _a, _b; startIdx <= endIdx; ++startIdx) {
        var listeners = void 0;
        const ch = vnodes[startIdx];
        if (null != ch) {
          if (void 0 !== ch.sel) {
            invokeDestroyHook(ch);
            listeners = cbs.remove.length + 1;
            listeners = createRmCb(ch.elm, listeners);
            for (var i = 0; i < cbs.remove.length; ++i) {
              cbs.remove[i](ch, listeners);
            }
            i = null === (_b = null === (_a = null === ch || void 0 === ch ? void 0 : ch.data) || void 0 === _a ? void 0 : _a.hook) || void 0 === _b ? void 0 : _b.remove;
            void 0 !== i ? i(ch, listeners) : listeners();
          } else {
            ch.children ? (invokeDestroyHook(ch), removeVnodes(parentElm, ch.children, 0, ch.children.length - 1)) : api.removeChild(parentElm, ch.elm);
          }
        }
      }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const hook = null === (_a = vnode.data) || void 0 === _a ? void 0 : _a.hook;
      null === (_b = null === hook || void 0 === hook ? void 0 : hook.prepatch) || void 0 === _b || _b.call(hook, oldVnode, vnode);
      _a = vnode.elm = oldVnode.elm;
      if (oldVnode !== vnode) {
        if (void 0 !== vnode.data || void 0 !== vnode.text && vnode.text !== oldVnode.text) {
          null !== (_c = vnode.data) && void 0 !== _c ? _c : vnode.data = {};
          null !== (_d = oldVnode.data) && void 0 !== _d ? _d : oldVnode.data = {};
          for (_c = 0; _c < cbs.update.length; ++_c) {
            cbs.update[_c](oldVnode, vnode);
          }
          null === (_g = null === (_f = null === (_e = vnode.data) || void 0 === _e ? void 0 : _e.hook) || void 0 === _f ? void 0 : _f.update) || void 0 === _g || _g.call(_f, oldVnode, vnode);
        }
        _f = oldVnode.children;
        _e = vnode.children;
        if (void 0 === vnode.text) {
          if (void 0 !== _f && void 0 !== _e) {
            if (_f !== _e) {
              _b = _g = 0;
              _c = _f.length - 1;
              var oldStartVnode = _f[0];
              let oldEndVnode = _f[_c];
              _d = _e.length - 1;
              let newStartVnode = _e[0], newEndVnode = _e[_d];
              for (var oldKeyToIdx, idxInOld, elmToMove; _g <= _c && _b <= _d;) {
                if (null == oldStartVnode) {
                  oldStartVnode = _f[++_g];
                } else if (null == oldEndVnode) {
                  oldEndVnode = _f[--_c];
                } else if (null == newStartVnode) {
                  newStartVnode = _e[++_b];
                } else if (null == newEndVnode) {
                  newEndVnode = _e[--_d];
                } else if (sameVnode(oldStartVnode, newStartVnode)) {
                  patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue), oldStartVnode = _f[++_g], newStartVnode = _e[++_b];
                } else if (sameVnode(oldEndVnode, newEndVnode)) {
                  patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue), oldEndVnode = _f[--_c], newEndVnode = _e[--_d];
                } else if (sameVnode(oldStartVnode, newEndVnode)) {
                  patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue), api.insertBefore(_a, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm)), oldStartVnode = _f[++_g], newEndVnode = _e[--_d];
                } else {
                  if (sameVnode(oldEndVnode, newStartVnode)) {
                    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue), api.insertBefore(_a, oldEndVnode.elm, oldStartVnode.elm), oldEndVnode = _f[--_c];
                  } else {
                    if (void 0 === oldKeyToIdx) {
                      oldKeyToIdx = void 0;
                      idxInOld = _f;
                      var beginIdx = _g;
                      elmToMove = _c;
                      const map = {};
                      for (; beginIdx <= elmToMove; ++beginIdx) {
                        const key = null === (oldKeyToIdx = idxInOld[beginIdx]) || void 0 === oldKeyToIdx ? void 0 : oldKeyToIdx.key;
                        void 0 !== key && (map[key] = beginIdx);
                      }
                      oldKeyToIdx = map;
                    }
                    idxInOld = oldKeyToIdx[newStartVnode.key];
                    void 0 === idxInOld ? api.insertBefore(_a, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm) : (elmToMove = _f[idxInOld], elmToMove.sel !== newStartVnode.sel ? api.insertBefore(_a, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm) : (patchVnode(elmToMove, newStartVnode, insertedVnodeQueue), _f[idxInOld] = void 0, api.insertBefore(_a, elmToMove.elm, oldStartVnode.elm)));
                  }
                  newStartVnode = _e[++_b];
                }
              }
              if (_b <= _d) {
                for (oldKeyToIdx = null == _e[_d + 1] ? null : _e[_d + 1].elm; _b <= _d; ++_b) {
                  oldStartVnode = _e[_b], null != oldStartVnode && api.insertBefore(_a, createElm(oldStartVnode, insertedVnodeQueue), oldKeyToIdx);
                }
              }
              _g <= _c && removeVnodes(_a, _f, _g, _c);
            }
          } else if (void 0 !== _e) {
            for (void 0 !== oldVnode.text && api.setTextContent(_a, ""), _f = 0, _g = _e.length - 1; _f <= _g; ++_f) {
              _c = _e[_f], null != _c && api.insertBefore(_a, createElm(_c, insertedVnodeQueue), null);
            }
          } else {
            void 0 !== _f ? removeVnodes(_a, _f, 0, _f.length - 1) : void 0 !== oldVnode.text && api.setTextContent(_a, "");
          }
        } else {
          oldVnode.text !== vnode.text && (void 0 !== _f && removeVnodes(_a, _f, 0, _f.length - 1), api.setTextContent(_a, vnode.text));
        }
        null === (_h = null === hook || void 0 === hook ? void 0 : hook.postpatch) || void 0 === _h || _h.call(hook, oldVnode, vnode);
      }
    }
    const cbs = {create:[], update:[], remove:[], destroy:[], pre:[], post:[]}, api = void 0 !== domApi ? domApi : htmlDomApi;
    for (const hook of hooks) {
      for (const module of modules) {
        domApi = module[hook], void 0 !== domApi && cbs[hook].push(domApi);
      }
    }
    return function(oldVnode, vnode$jscomp$0) {
      var i;
      const insertedVnodeQueue = [];
      for (i = 0; i < cbs.pre.length; ++i) {
        cbs.pre[i]();
      }
      if (api.isElement(oldVnode)) {
        i = oldVnode.id ? "#" + oldVnode.id : "";
        var parent = (parent = oldVnode.getAttribute("class")) ? "." + parent.split(" ").join(".") : "";
        oldVnode = vnode(api.tagName(oldVnode).toLowerCase() + i + parent, {}, [], void 0, oldVnode);
      } else {
        api.isDocumentFragment(oldVnode) && (oldVnode = vnode(void 0, {}, [], void 0, oldVnode));
      }
      sameVnode(oldVnode, vnode$jscomp$0) ? patchVnode(oldVnode, vnode$jscomp$0, insertedVnodeQueue) : (i = oldVnode.elm, parent = api.parentNode(i), createElm(vnode$jscomp$0, insertedVnodeQueue), null !== parent && (api.insertBefore(parent, vnode$jscomp$0.elm, api.nextSibling(i)), removeVnodes(parent, [oldVnode], 0, 0)));
      for (i = 0; i < insertedVnodeQueue.length; ++i) {
        insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
      }
      for (i = 0; i < cbs.post.length; ++i) {
        cbs.post[i]();
      }
      return vnode$jscomp$0;
    };
  };
  exports.jsx = jsx;
  exports.primitive = primitive;
  exports.propsModule = propsModule;
  exports.styleModule = styleModule;
  exports.thunk = function(sel, key, fn, args) {
    void 0 === args && (args = fn, fn = key, key = void 0);
    return h(sel, {key, hook:{init, prepatch}, fn, args});
  };
  exports.toVNode = toVNode;
  exports.vnode = vnode;
};

//# sourceMappingURL=module$node_modules$snabbdom$build$snabbdom_cjs.js.map
